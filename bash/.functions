# Create a new directory and enter it
md()
{
    mkdir -pv "$@" && cd "$@"
}

# find shorthand
f()
{
    find . -name "$1"
}

# Goto temp dir
cd-temp()
{
    [ -z "$TMPDIR" ] && cd /tmp || cd "$TMPDIR"
}

# Simple calculator
calc()
{
    local result=""
    result="$(printf "scale=10;$*\n" | bc --mathlib | tr -d '\\\n')"
    #                       └─ default (when `--mathlib` is used) is 20

    if [[ "$result" == *.* ]]; then
        # improve the output for decimal numbers
        printf "$result" |
        sed -e 's/^\./0./' \
            -e 's/^-\./-0./' \
            -e 's/0*$//;s/\.$//'
    else
        printf "$result"
    fi

    printf "\n"
}

# Determine size of a file or total size of a directory
filesize()
{
    if du -b /dev/null > /dev/null 2>&1; then
        local arg=-sbh
    else
        local arg=-sh
    fi
    if [[ -n "$@" ]]; then
        du $arg -- "$@"
    else
        du $arg .[^.]* *
    fi
}

# Create a data URL from a file
dataurl()
{
    local mimeType=$(file -b --mime-type "$1")
    if [[ $mimeType == text/* ]]; then
        mimeType="${mimeType};charset=utf-8"
    fi
    echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Use PHP's built-in support to encode and decode base64.
base64()
{
    if [ $# -eq 0 ]; then
         echo 'Usage: base64 [encode|decode] <string>';
         return;
    fi;
    local action='decode';
    if [ "$1" = 'decode' ]; then
        action='decode';
        shift;
    elif [ "$1" = 'encode' ]; then
        action='encode';
        shift;
    fi;
    echo "$@" | php -r "echo base64_$action(file_get_contents('php://stdin'));";
    echo;
}

# Start an HTTP server from a directory, optionally specifying the port
server()
{
    local port="${1:-8000}"
    open "http://localhost:${port}/"
    # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
    # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
    python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
phpserver()
{
    local port="${1:-4000}"
    local ip=$(ipconfig getifaddr en1)
    sleep 1 && open "http://${ip}:${port}/" &
    php -S "${ip}:${port}"
}

# Extract archives - use: extract <file>
# Based on http://dotfiles.org/~pseup/.bashrc
extract()
{
    if [ -f "$1" ] ; then
        local filename=$(basename "$1")
        local foldername="${filename%%.*}"
        local fullpath=`perl -e 'use Cwd "abs_path";print abs_path(shift)' "$1"`
        local didfolderexist=false
        if [ -d "$foldername" ]; then
            didfolderexist=true
            read -p "$foldername already exists, do you want to overwrite it? (y/n) " -n 1
            echo
            if [[ $REPLY =~ ^[Nn]$ ]]; then
                return
            fi
        fi
        mkdir -p "$foldername" && cd "$foldername"
        case $1 in
            (*.tar.bz2) tar xjf "$fullpath" ;;
            (*.tar.gz) tar xzf "$fullpath" ;;
            (*.tar.xz) tar Jxvf "$fullpath" ;;
            (*.tar.Z) tar xzf "$fullpath" ;;
            (*.tar) tar xf "$fullpath" ;;
            (*.taz) tar xzf "$fullpath" ;;
            (*.tb2) tar xjf "$fullpath" ;;
            (*.tbz) tar xjf "$fullpath" ;;
            (*.tbz2) tar xjf "$fullpath" ;;
            (*.tgz) tar xzf "$fullpath" ;;
            (*.txz) tar Jxvf "$fullpath" ;;
            (*.zip|*.war|*.jar) unzip "$fullpath" ;;
            (*.rar) unrar x -ad "$fullpath" ;;
            (*.7z) 7za x "$fullpath" ;;
            (*) echo "'$1' cannot be extracted via extract()" && cd .. && ! $didfolderexist && rm -r "$foldername" ;;
        esac
    else
        echo "'$1' is not a valid file"
    fi
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
s()
{
    if [ $# -eq 0 ]; then
        subl .
    else
        subl "$@"
    fi
}

# `o` with no arguments opens current directory, otherwise opens the given
# location
o()
{

    local fm=
    if command -v nautilus > /dev/null; then
        fm='nautilus'
    elif command -v open > /dev/null; then
        fm='open'
    fi;

    if [ $# -eq 0 ]; then
        $fm .
    else
        $fm "$@"
    fi
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
tre()
{
    tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX
}

# Get the introductory paragraph from a Wikipedia article using the inimitable
# David Leadbeater's Wikipedia-over-DNS service.
#
# See https://dgl.cx/wikipedia-dns
wp()
{
    query="$*";
    domain="${query// /_}.wp.dg.cx";
    answer="$(dig +short -t txt "$domain" | perl -p -e 's/\\([0-9]*)/chr($1)/eg')";
    answer="${answer:1}";

    while [ -n "$answer" ]; do
        chunk_length=255;
        [ "${#answer}" -lt 256 ] && chunk_length=$((${#answer} - 1));
        text="${text}${answer:0:$chunk_length}";
        answer="${answer:$(($chunk_length + 3))}";
    done;

    echo "$text";
}

# Show a unified diff, colourised if possible and paged if necessary.
udiff()
{
    if command -v colordiff > /dev/null; then
        colordiff -wU4 "$@" | $PAGER;
        return ${PIPESTATUS[0]};
    elif command -v git > /dev/null && ! [[ " $* " =~ \ /dev/fd ]]; then
        git diff --no-index "$@";
        return $?;
    fi;

    diff -wU4 -x .svn "$@" | $PAGER;
    return ${PIPESTATUS[0]};
}

# Sort the "du" output and use human-readable units.
duh()
{
    du -sk "$@" | sort -n | while read size fname; do
        for unit in KiB MiB GiB TiB PiB EiB ZiB YiB; do
            if [ "$size" -lt 1024 ]; then
                echo -e "${size} ${unit}\t${fname}";
                break;
            fi;
            size=$((size/1024));
        done;
    done;
}

# Edit the files found with the previous "ack" command using Vim (or the
# default editor).
vack()
{
    local cmd='';
    if [ $# -eq 0 ]; then
        cmd="$(fc -nl -1)";
        cmd="${cmd:2}";
    else
        cmd='ack';
        for x; do
            cmd="$cmd $(printf '%q' "$x")";
        done;
        echo "$cmd";
    fi;
    if [ "${cmd:0:4}" != 'ack ' ]; then
        $cmd;
        return $?;
    fi;
    declare -a files;
    while read -r file; do
        echo "$file";
        files+=("$file");
    done < <(bash -c "${cmd/ack/ack -l}");
    vim -p "${files[@]}";
}

# Convert the parameters or STDIN to lowercase.
lc()
{
    if [ $# -eq 0 ]; then
        tr '[:upper:]' '[:lower:]';
    else
        tr '[:upper:]' '[:lower:]' <<< "$@";
    fi;
}

# Convert the parameters or STDIN to uppercase.
uc()
{
    if [ $# -eq 0 ]; then
        tr '[:lower:]' '[:upper:]';
    else
        tr '[:lower:]' '[:upper:]' <<< "$@";
    fi;
}

# Try to make sense of the date. It supports everything GNU date knows how to
# parse, as well as UNIX timestamps. It formats the given date using the
# default GNU date format, which you can override using "--format='%x %y %z'.
#
# Examples of input and output:
#
#   $ whenis 1234567890            # UNIX timestamps
#   Sat Feb 14 00:31:30 CET 2009
#
#   $ whenis +1 year -3 months     # relative dates
#   Fri Jul 20 21:51:27 CEST 2012
#
#   $ whenis 2011-10-09 08:07:06   # MySQL DATETIME strings
#   Sun Oct  9 08:07:06 CEST 2011
#
#   $ whenis 1979-10-14T12:00:00.001-04:00 # HTML5 global date and time
#   Sun Oct 14 17:00:00 CET 1979
#
#   $ TZ=America/Vancouver whenis # Current time in Vancouver
#   Thu Oct 20 13:04:20 PDT 2011
#
# For more info, check out http://kak.be/gnudateformats.
whenis()
{
    local error='Unable to parse that using http://kak.be/gnudateformats';

    # Default GNU date format as seen in date.c from GNU coreutils.
    local format='%a %b %e %H:%M:%S %Z %Y';
    if [[ "$1" =~ ^--format= ]]; then
        format="${1#--format=}";
        shift;
    fi;

    # Concatenate all arguments as one string specifying the date.
    local date="$*";
    if [[ "$date"  =~ ^[[:space:]]*$ ]]; then
        date='now';
    elif [[ "$date"  =~ ^[0-9]{13}$ ]]; then
        # Cut the microseconds part.
        date="${date:0:10}";
    fi;

    if [[ "$OSTYPE" =~ ^darwin ]]; then
        # Use PHP on OS X, where "date" is not GNU's.
        php -r '
            error_reporting(-1);
            $format = $_SERVER["argv"][1];
            $date = $_SERVER["argv"][2];
            if (!is_numeric($date)) {
                $date = strtotime($date);
                if ($date === false) {
                    fputs(STDERR, $_SERVER["argv"][3] . PHP_EOL);
                    exit(1);
                }
            }
            echo strftime($format, $date), PHP_EOL;
        ' -- "$format" "$date" "$error";
    else
        # Use GNU date in all other situations.
        [[ "$date" =~ ^[0-9]+$ ]] && date="@$date";
        date -d "$date" +"$format";
    fi;
}

# Do a mysqldump via ssh and store it in a local timestamped file. This
# function assumes proper setup in your local ~/.ssh/config and the remote
# ~/.my.cnf.
ssh-mysqldump()
{
    local timestamp="$(date +'%Y%m%d-%H%M%S')";
    if [ -z "$1" -o "$1" = '--help' ]; then
        local filename="$timestamp-ssh_host-database_name.sql";
        echo "Usage: ${FUNCNAME[0]} ssh_host [database_name]";
        echo "This will create a file called $filename in this directory.";

        # Do not return an error when the user explicitly requested help.
        [ "$1" = '--help' ];
        return $?;
    fi >&2;

    # Determine the host and the database, with the database name defaulting
    # to the host name (or SSH config alias).
    local host="$1";
    local database="$host";
    shift;
    if (($#)) && [ "${1:0:1}" != '-' ]; then
        database="$1";
        shift;
    fi;

    # I prefer one INSERT statement per record, so by default, disable the
    # extended INSERT syntax. Unless there is an explicit option in the
    # arguments.
    local has_extended_insert_option=false;

    # By default, do not lock the tables while dumping. This is slightly less
    # accurate, but locking tables used in production can wreak havoc. Prefer
    # uptime to correctness.
    local has_lock_all_tables_option=false;
    local has_lock_tables_option=false;

    local arg opts=() args=();
    for arg; do
        # Escape the meta-characters in the arguments so they are safe for
        # the remote shell.
        if [ "${arg:0:1}" = '-' ]; then
            opts+=("$(printf '%q' "$arg")");
        else
            args+=("$(printf '%q' "$arg")");
        fi;

        # See if our default options are overridden.
        if [[ "$arg" =~ ^--(skip-)?extended-insert$ ]]; then
            has_extended_insert_option=true;
        elif [[ "$arg" =~ ^--(skip-)?lock-all-tables$ ]]; then
            has_lock_all_tables_option=true;
        elif [[ "$arg" =~ ^--(skip-)?lock-tables$ ]]; then
            has_lock_tables_option=true;
        fi;
    done;
    $has_extended_insert_option || opts+=('--skip-extended-insert');
    $has_lock_all_tables_option || opts+=('--skip-lock-all-tables');
    $has_lock_tables_option || opts+=('--skip-lock-tables');
    local filename="$timestamp-${host//\//-}-${database//\//-}.sql";

    # Finally, run the remote mysqldump and store the result locally.
    # If you want compression, set it in your ~/.ssh/config. I quote the man
    # page: "[ Compression ] will only slow down things on fast networks."
    if [ -t 1 ]; then
        ssh -- "$host" mysqldump "${opts[@]}" "$database" "${args[@]}" > "$filename";
    else
        echo "Stdout is not a terminal, so I won't save to $filename." >&2;
        ssh -- "$host" mysqldump "${opts[@]}" "${args[@]}" "$database";
    fi;
    local result=$?;

    if [ -s "$filename" ]; then
        ls -dalF "$filename";
    else
        rm -f "$filename";
    fi;
    return $result;
}

# Delete host from known_hosts if node was reinstalled
ssh-refresh()
{
    ssh-keygen -f "$HOME/.ssh/known_hosts" -R $1
}

# Copy specified ssh key to another machine
ssh-copy-key()
{
    local key="$1"
    local host="$2"
    local user="$3"

    cat "$key" | ssh "$host" -l "$user" "cat - >> ~/.ssh/authorized_keys"
    echo "ssh command copied to clipboard"
    echo "ssh $host -l $user" | pbcopy
}

ssh-set-config()
{
    local key="$1"
    local host="$2"
    local user="$3"

    cat >> ~/.ssh/config <<EOF
Host $host
User $user
IdentityFile $key

EOF
    echo "ssh command copied to clipboard"
    echo "ssh $host" | pbcopy
}

ssh-is-available()
{
    local hostname="$1"
    netcat -v -w 1 $hostname 22
}

# Generate random password
pswdgen()
{
    local length="$1"

    [ -z "$length" ] && length="12" || length="$length"
    LC_ALL=C tr -dc 'A-Za-z0-9_!@#$%^&*()\-+=' < /dev/urandom | head -c "$length" | xargs
    LC_ALL=C tr -dc 'A-Za-z0-9' < /dev/urandom | head -c "$length" | xargs
}

# Usage "review [new|id] path/to/files"
review()
{
    ~/ccollab-cmdline/ccollab addchanges --diffbranch "svn info | sed -n -e '/^Revision: \([0-9]*\).*$/s//\1/p'" "$@"
}

# Simple notes
note()
{
    local destination="$HOME"
    # if Dropbox installed, save into it for sync
    [ ! -d "$HOME/Dropbox" ] || destination="$HOME/Dropbox"
    local notes="$destination/.notes"

    # if file doesn't exist, create it
    if [[ ! -f $notes ]]; then
        touch $notes
    fi

    if ! (($#)); then
        # no arguments, print file
        cat $notes
    elif [[ "$1" == "-c" ]]; then
        # clear file
        > $notes
    else
        # add all arguments to file
        printf "%s\n" "`date "+%A, %B %d, %Y [%T]"`" "====" "$*" "" >> $notes
    fi
}

upgrade-python-in-virtualenv()
{
    local target="$1"

    find "$target/" -type l -delete
    virtualenv "$target"
}

git-delete-merged-branches()
{
    git branch --merged | grep -v "\*" | xargs -n 1 git branch -d
}

