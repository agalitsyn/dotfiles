" Environment {

    " Basics {
        set nocompatible " Use Vim settings, rather than Vi settings (much better!)
    " }

    " Setup Bundle Support {
        " The next three lines ensure that the ~/.vim/bundle/ system works
        filetype on     " workaround for macosx
        filetype off    " required
        set rtp+=~/.vim/bundle/vundle
        call vundle#rc()
    " }
" }

" Use bundles config {
    if filereadable(expand("~/.vimrc.bundles"))
        source ~/.vimrc.bundles
    endif
" }

" General {

    set t_Co=256                   " Xterm 256 colors
    set background=dark            " Assume a dark background
    filetype plugin indent on      " Automatically detect file types.
    syntax on                      " Syntax highlighting
    set mouse=a                    " Automatically enable mouse usage
    set mousehide                  " Hide the mouse cursor while typing
    set encoding=utf-8 nobomb      " BOM often causes trouble
    set hidden                     " Allow buffer switching without saving
    set virtualedit=onemore        " Allow for cursor beyond last character
    set history=1000               " Store a ton of history (default is 20)
    " set spell                    " Spell checking on
    set autowrite                " Automatically write a file when leaving a modified buffer

    " Setting up the directories {
        set nobackup            " Do not keep a backup file, use versions instead.
        if has('persistent_undo')
            set undofile            " So is persistent undo ...
            set undolevels=1000     " Maximum number of changes that can be undone
            set undoreload=10000    " Maximum number lines to save for undo on a buffer reload
        endif

        if !isdirectory($HOME . '/.vim/backups')
            call mkdir($HOME . '/.vim/backups', 'p')
        endif

        if !isdirectory($HOME . '/.vim/swaps')
            call mkdir($HOME . '/.vim/swaps', 'p')
        endif

        if !isdirectory($HOME . '/.vim/undo')
            call mkdir($HOME . '/.vim/undo', 'p')
        endif

        set backupdir=~/.vim/backups
        set directory=~/.vim/swaps
        set undodir=~/.vim/undo
    " }

    let mapleader=","   " change leader to comma
" }

" Vim UI {

    if filereadable(expand("~/.vim/bundle/vim-colors-solarized/colors/solarized.vim"))
        colorscheme solarized  " Load a colorscheme
    endif

    "if filereadable(expand("~/.vim/bundle/jellybeans.vim/colors/jellybeans.vim"))
    "    colorscheme jellybeans " Load a colorscheme
    "endif

    set showmode                    " Display the current mode
    set cursorline                  " Highlight current line

    highlight clear SignColumn      " SignColumn should match background
    highlight clear LineNr          " Current line number row will have same background color in relative mode
    "highlight clear CursorLineNr   " Remove highlight color from current line number

    if has('cmdline_info')
        set ruler                   " Show the ruler
        set rulerformat=%30(%=\:b%n%y%m%r%w\ %l,%c%V\ %P%) " A ruler on steroids
        set showcmd                 " Show partial commands in status line and
                                    " Selected characters/lines in visual mode
    endif

    if has('statusline')
        set laststatus=2

        " Broken down into easily includeable segments
        set statusline=%<%f\                     " Filename
        set statusline+=%w%h%m%r                 " Options
        "set statusline+=%{fugitive#statusline()} " Git Hotness
        set statusline+=\ [%{&ff}/%Y]            " Filetype
        set statusline+=\ [%{getcwd()}]          " Current dir
        set statusline+=%=%-14.(%l,%c%V%)\ %p%%  " Right aligned file nav info
    endif

    "========== TextMate-Style Visible Whitespace ===========

    " Shortcut to rapidly toggle `set list`
    nmap <leader>t :set list!<CR>

    " Use cool symbols for tabstops and EOLs
    set listchars=tab:▸\ ,eol:¬

    "========================================================

    if has("autocmd")
        " Jump to the last position when reopening a file
        au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$")
            \| exe "normal! g'\"" | endif

        " in insert mode, auto turn on absolute numbered lines
        autocmd InsertEnter * :set number
        autocmd InsertLeave * :set relativenumber

        " in insert mode, auto turn on absolute numbered lines
        autocmd InsertEnter * :set number
        autocmd InsertLeave * :set relativenumber

        " change status line color based on mode
        hi statusline term=reverse ctermfg=0 ctermbg=2
        au InsertEnter * hi statusline term=reverse ctermbg=4 gui=undercurl guisp=Magenta
        au InsertLeave * hi statusline term=reverse ctermfg=0 ctermbg=2 gui=bold,reverse

        " Syntax of these languages is fussy over tabs Vs spaces
        autocmd FileType make setlocal ts=8 sts=8 sw=8 noexpandtab

        " Treat .rss files as XML
        autocmd BufNewFile,BufRead *.rss setfiletype xml
    endif

    set bs=indent,eol,start         " Allow backspacing over everything in insert mode
    set linespace=0                 " No extra spaces between rows
    set relativenumber              " Mix relative and absolute numbers
    set number
    set showmatch                   " Show matching brackets/parenthesis
    set incsearch                   " Find as you type search
    set hlsearch                    " Highlight search terms
    set ignorecase                  " Case insensitive search
    set smartcase                   " Case sensitive when uc present
    set magic                       " Enable extended regexes.
    set title                       " Show the filename in the window titlebar.
    set splitright                  " Puts new vsplit windows to the right of the current
    set splitbelow                  " Puts new split windows to the bottom of the current
    set esckeys                     " Allow cursor keys in insert mode.
    set diffopt=filler              " Add vertical spaces to keep right and left aligned.
    set diffopt+=iwhite             " Ignore whitespace changes (focus on code changes).
" }

" Formatting {

    set nowrap          " Do not wrap lines.
    set autoindent      " Copy indent from last line when starting new line.
    set smartindent     " Know about functions end while intending.
    set expandtab       " Expand tabs to spaces
    set shiftwidth=4    " Control how many columns text is indented with the reindent operations.
    set softtabstop=4   " Control how many columns vim uses when you hit Tab in insert mode.
    set tabstop=4       " Tell vim how many columns a tab counts for.
" }

" Key (re)Mappings {

    " Don't use Ex mode, use Q for formatting
    map Q gq

    " CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
    " so that you can undo CTRL-U after inserting a line break.
    inoremap <C-U> <C-G>u<C-U>

    " insert new line without entering insert mode.
     map <CR> o<Esc>

    " Convenient command to see the difference between the current buffer and the
    " file it was loaded from, thus the changes you made.
    " Only define it when not defined already.
    if !exists(":DiffOrig")
      command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
              \ | wincmd p | diffthis
    endif

    " Faster split resizing (+,-)
    if bufwinnr(1)
      map + <C-W>+
      map - <C-W>-
    endif

    " Better split switching (Ctrl-j, Ctrl-k, Ctrl-h, Ctrl-l)
    map <C-j> <C-W>j
    map <C-k> <C-W>k
    map <C-H> <C-W>h
    map <C-L> <C-W>l

    " Save with sudo
    command W :execute ':silent w !sudo tee % > /dev/null' | :edit!
    command Wq :execute ':silent w !sudo tee % > /dev/null' | :quit!

    " Insert newline
    map <leader><Enter> o<ESC>

    " ,s to toggle syntax on/off
    nnoremap <Leader>s :call SyntaxToggle()<CR>

    " ,n to toggle rnu
    nnoremap <Leader>n :call NumberToggle()<CR>

    " ,cd to move to file's working directory
    nnoremap <Leader>cd :lcd %:h<CR>

    " toggle nerdtree with f7
    map <F7> :NERDTreeToggle<CR>

    " delete whitespace at eols with F9
    nnoremap <silent> <F9> :call <SID>StripTrailingWhitespaces()<CR>

    "=============== Strip Trailing Whitespace ==============

    function! <SID>StripTrailingWhitespaces()
        " Preparation: save last search, and cursor position.
        let _s=@/
        let l = line(".")
        let c = col(".")
        " Do the business:
        %s/\s\+$//e
        " Clean up: restore previous search history, and cursor position
        let @/=_s
        call cursor(l, c)
    endfunction

    "========================================================

    "======================= Saving =========================

    " If the current buffer has never been saved, it will have no name,
    " call the file browser to save it, otherwise just save it.
    command -nargs=0 -bar Update if &modified
                            \|    if empty(bufname('%'))
                            \|        browse confirm write
                            \|    else
                            \|        confirm write
                            \|    endif
                            \|endif
    " Ctrl-s to save in normal mode
    nnoremap <silent> <C-S> :<C-u>Update<CR>
    " Ctrl-s to save while in insert mode
    inoremap <c-s> <c-o>:Update<CR>

    "========================================================

    "==================== X11 Clipboard =====================

    " CTRL-X and SHIFT-Del are Cut
    vnoremap <C-X> "+x
    vnoremap <S-Del> "+x

    " CTRL-C and CTRL-Insert are Copy
    vnoremap <C-C> "+y
    vnoremap <C-Insert> "+y

    " CTRL-V and SHIFT-Insert are Paste
    map <C-V> "+gP
    map <S-Insert> "+gP

    cmap <C-V> <C-R>+
    cmap <S-Insert> <C-R>+

    "========================================================

    "=================== Smooth Scrollin' ===================

    "noremap <silent> <C-U> :call smooth_scroll#up(&scroll, 20, 2)<CR>
    "noremap <silent> <C-D> :call smooth_scroll#down(&scroll, 20, 2)<CR>
    "noremap <silent> <C-B> :call smooth_scroll#up(&scroll*2, 0, 4)<CR>
    "noremap <silent> <C-F> :call smooth_scroll#down(&scroll*2, 0, 4)<CR>

    "========================================================

    "========================= Misc =========================

    " CTRL-U in insert mode deletes a lot.  Use CTRL-G u to first break undo,
    " so that you can undo CTRL-U after inserting a line break.
    inoremap <C-U> <C-G>u<C-U>

    " function to toggle rnu and nu
    function! NumberToggle()
        if(&relativenumber == 1)
            set number
        else
            set relativenumber
        endif
    endfunc

    " function to toggle syntax on and off
    function! SyntaxToggle()
        if(&syntax == 1)
            syntax off
        else
            syntax on
        endif
    endfunc

    " hide search hl with ctrl+l
    nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>

    " Convenient command to see the difference between the current buffer and the
    " file it was loaded from, thus the changes you made.
    " Only define it when not defined already.
    if !exists(":DiffOrig")
        command DiffOrig vert new | set bt=nofile | r ++edit # | 0d_ | diffthis
            \ | wincmd p | diffthis
        endif

    "========================================================
" }
